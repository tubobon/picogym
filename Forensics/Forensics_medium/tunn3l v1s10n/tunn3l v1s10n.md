# tunn3l v1s10n
## 解法
謎のバイナリファイルが与えられる問題です.\
`xxd`すると、
```
00000000: 424d 8e26 2c00 0000 0000 bad0 0000 bad0  BM.&,...........
00000010: 0000 6e04 0000 3201 0000 0100 1800 0000  ..n...2.........
00000020: 0000 5826 2c00 2516 0000 2516 0000 0000  ..X&,.%...%.....
00000030: 0000 0000 0000 231a 1727 1e1b 2920 1d2a  ......#..'..) .*
00000040: 211e 261d 1a31 2825 352c 2933 2a27 382f  !.&..1(%5,)3*'8/
00000050: 2c2f 2623 332a 262d 2420 3b32 2e32 2925  ,/&#3*&-$ ;2.2)%
00000060: 3027 2333 2a26 382c 2836 2b27 392d 2b2f  0'#3*&8,(6+'9-+/
00000070: 2623 1d12 0e23 1711 2916 0e55 3d31 9776  &#...#..)..U=1.v
00000080: 668b 6652 996d 569e 7058 9e6f 549c 6f54  f.fR.mV.pX.oT.oT
00000090: ab7e 63ba 8c6d bd8a 69c8 9771 c193 71c1  .~c..m..i..q..q.
```
とbmpファイルのマジックナンバーが見て取れます。\
しかし、fileコマンドでdataと出ることから何かがおかしい。\
例えばpngに関しては、マジックナンバーに加え,IHDR,IDAT,IENDがそろっている場合に画像を表示できるという仕組みなのだが、bmpに関してはよくわからないことが多い。\
geminiによると、bmpの画像の構造情報を持っているのは、マジックナンバーの次の部分(ビットで言うと10ビット目ぐらいから)らしい。バイナリではbadの部分がちょうど該当する。\
ここが正しくないとbmpとして認識できないらしく、`dd`コマンドでその部分を書き換えた。`printf '\x36\x00\x00\x00\x38\x00' | dd of=tunn3l_v1s10n.bmp  bs=1 seek=10 conv=notrunc`\
(36 00はbmpの画像データがどこから始まるのかの指定、38 00は情報ヘッダの形式を示すサイズを指定するらしい)\
書き換えを行い`file`コマンドを実行すると正しくbmpと認識できた。\
しかしまだ、画像を開くと偽物のflagしかない。\
今回のファイルの大きさは約2.8Mbyteなのだが、exiftoolで確認すると1134px * 306px * 3byteの約1Mbyteしか表示されていないという。\
よってファイルの大きさから残りの縦の長さを逆算するにおよそ縦幅が、850pxになればよいので、`dd`コマンドを使って書き換えを行った。（バイナリの場所はさっきの後ぐらいにある）\
上方に拡大されたbmpを確認するとflagを発見した。`picoCTF{qu1t3_a_v13w_2020}`\
### 余談
余談になるけど、基本的に今回のようなファイルのサイズから本来の縦横を逆算できるのは、bmp形式だけである。(pngやjpegはデータを圧縮するから)\
![alt text](tunn3l_v1s10n.bmp)
